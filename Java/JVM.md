# JVM
## JVM内存区域
![JVM内存模型-1.8之前](https://gitee.com/dreamcater/blog-img/raw/master/uPic/JVM内存模型-1.8之前-EKvhGB.png)

![JVM内存模型-1.8](https://gitee.com/dreamcater/blog-img/raw/master/uPic/JVM内存模型-1.8-y9XNlT.png)
> 粗略的氛围**堆和栈**，那么栈是线程私有的，而堆是线程共享的。栈又分为程序计数器、虚拟机栈、本地方法栈

### 程序计数器
* **字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制**。如：顺序执行、选择、循环、异常处理
* 在多线程的情况下，程序计数器用于记录当前线程的执行位置，从而当线程被切换回来的时候能够知道线程上次运行到哪儿
* 程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡

### 虚拟机栈
* 通俗的讲，主要是**对象中的方法产生的各种"材料"**
* 虚拟机栈存放的是**局部变量、操作数栈、动态链接、方法出口**
* 局部变量表存8大基本数据类型以及引用类型
* 栈的Error
  * **StackOverFlowError**：若Java虚拟机的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，叫抛出异常
  * **OutOfMemoryError**：若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，就抛出异常

### 本地方法栈
> 虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而**本地方法栈则为虚拟机使用到的Native方法服务**

### 方法区
> **方法区与 Java 堆一样，是各个线程共享的内存区域**，它用于存储已被虚拟机加载的**类信息**、**常量**、**静态变量**、即时编译器编译后的代码等数据。不过随着版本的变化，会发生变化。
- 1.6:运行时常量池在Perm Gen区(也就是方法区)中；字符串常量池在**运行时常量池**中。
- 1.7:运行时常量池依然在Perm Gen区(也就是方法区)中在JDK7版本中，永久代的转移工作就已经开始了，将譬如**符号引用转移到了native heap**；**字面量转移到了java heap**；**类的静态变量转移到了java heap**。但是运行时常量池依然还存在，只是很多内容被转移，其只存着这些被转移的引用；字符串常量池被分配到了**Java堆的主要部分**。也就是字符串常量池从运行时常量池分离出来了。
- 1.8:JVM已经将**运行时常量池从方法区中移了出来**，在**Java 堆（Heap）中开辟了一块区域存放运行时常量池**。同时永久代被移除，**以元空间代替**。**元空间并不在虚拟机中，而是使用本地内存**；**字符串常量池存在于Java堆中**。

方法区，依然会发生error，因为在之前的版本中，**当一个类启动的时候，也会加载很多class文件**，那么也会充满整个方法区，当满的时候，也会error的，当然，在以前的版本中，字符串常量池在方法区中，而**使用String.intern()方法，依然会占满空间并error**。

### 直接内存
> 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemory异常出现（如DirectByteError）。本机直接内存的分配不会受到java堆的限制，但会受到本机总内存大小以及处理器寻址空间的限制

### 堆
> 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存
* 分为四个区，分别为**eden区、s0(From)区、s1（To）区和tentired区**
* 在初始阶段，新创建的对象被分配到Eden区，survivor的两块空间都为空
* 当eden区满的时候，minor GC触发
* 经过扫描与标记，存活的对象被复制到s0，不存活的对象被回收
* 在下一次的minior GC中，eden区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到survivor区。然而在survivor区，S0的所有的数据都被复制到S1，需要注意的是，在上次minor GC过程中移动到S0中的相同存活的对象在复制到S1后其年龄要加1。此时Eden区S0区被清空，所有存活的数据都复制到了S1区，并且S1区存在着年龄不一样的对象（重点）
* 再下一次minor GC则重复这个过程，这一次survivor的两个区对换，存活的对象被复制到s0，存活的对象年龄加一，eden区和另一个survivor区清空

### Minor GC和Full GC触发条件
* Minor GC触发条件：当eden区满时，触发
* Full GC触发条件：
  * 调用System.GC时，系统建议执行Full GC，但是不必然执行
  * 老年代空间不足
  * 方法区空间不足
  * 通过minor gc后进入老年代的平均大小大于老年代的可用内存
  * 由eden区，from区向to区复制时，对象大小大于to区可用内存，则把该对象转移到老年代，且老年代的可用内存大小小于该对象 



## 对象的创建过程
![Java创建对象的过程](https://gitee.com/dreamcater/blog-img/raw/master/uPic/Java创建对象的过程-fC0wRb.png)
### 类加载检查
> 虚拟机遇到一条**new**指令时，首先将去检查这个指令的参数**是否能在常量池中定位到这个类的符号引用**，并且检查这个符号引用代表的**类是否已经被加载、解析和初始化过**。如果没有，那必须先执行相应的类加载过程

### 分配内存
> 在**类加载检查**过后，接下来虚拟将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从java堆中划分出来。分配方式有**指针碰撞**和**空闲列表**两种，**选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由采用的垃圾收集器是否带有压缩整理功能决定**
- **指针碰撞**
  - **堆规整（没有内存碎片）**
  - 复制算法
  - GC：Serial、ParNew
- **空闲列表**
  - **堆内存不规整的情况下**
  - 虚拟机会维护一个**列表**，该列表会**记录哪些内存块是可用的**，在分配的时候，找一块儿足够大的内存块来划分给对象实例，最后更新列表激励
  - GC：CMS

- **并发问题**
  - **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
  - **TLAB：** 为**每一个线程预先在 Eden 区分配一块儿内存**，JVM 在给线程中的对象分配内存时，**首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配**

### 初始化零值
> 内存分配完成后，虚拟机需要将分配到的内存空间都**初始化为零值（不包括对象头）**，这一步操作保证了对象的实例字段在Java代码中**可以不赋初值就可以直接使用**，程序能访问到这些字段的数据类型所对应的零值

### 设置对象头
> 初始化零值完成后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。**这些信息存放在对象头中**，另外，根据虚拟机当前运行状态的不同，对象会有不同的设置方式

### 执行init方法
> 上述流程完成后，从虚拟机视角看，一个对象已经产生，但从Java程序看，对象创建CIA刚开始：**方法还没有执行，所有的字段还为零。所以一般来说，执行new指令之后接着执行方法**，把对象按照程序员的医院进行初始化。

### 对象的访问方式
> 句柄和直接使用指针
#### 句柄
![使用句柄-f4Cw9x](https://gitee.com/dreamcater/blog-img/raw/master/uPic/使用句柄-f4Cw9x.png)
> 如果使用句柄，Java堆中将会划出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而**句柄中包含了对象实例数据与类型数据**各组的具体地址信息

#### 直接指针
![直接指针-8m3HHz](https://gitee.com/dreamcater/blog-img/raw/master/uPic/直接指针-8m3HHz.png)
> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。

#### 区别
> 这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是**稳定**的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 **reference 本身不需要修改**。使用直接指针访问方式最大的好处就是**速度快**，它节省了一次指针定位的时间开销。


## 垃圾回收
### 垃圾回收算法
* **标记-清除**
> 算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到，带来两个明显的问题：
>  * 效率问题
> * 空间问题（清楚后产生大量不连续的碎片）

* **标记-整理**
> 根据老年代的特点提出的一种标记方法，标记过程与“标记-清除”一样，但后续步骤不是直接对可回收对象回收，而是让**所有存活的对象向一端移动**，然后直接清理掉端边界以外的内存。（老年代一般存入的是大、时间比较久的对象）

* **复制**
> 为了解决效率问题，‘复制’收集算法出现了。将**内存分为大小相同的两块**，每次使用其中的一块，当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。**这样使每次的内存回收都是对内存区间的一半进行回收**（堆的年轻代又分为eden，s0，s1）

* **分代**
> 比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率比较高，而且没有额外的空间对他进行分配担保，所以我么必须选择**标记-清除或标记-整理算法**进行垃圾回收
- 大多数情况下，**对象在新生代中 eden 区分配**。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.
- **大对象直接进入老年代**，大对象就是需要**大量连续内存空间的对象**（比如：字符串、数组）。频繁复制降低性能。
- 如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1. 对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被**晋升到老年代**中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

### 如何判断对象死亡
#### 引用计数法
* 给对象添加一个引用计数器，每当有地方引用它，计数器就加一；当引用失效，计数器就减一；任何技术为0的对象是不可能再被使用的
* 此方法实现简单、效率高，但目前主流虚拟机并没有选择这个算法管理内存，主要原因在于很难解决独享之间相互循环引用的问题


#### 可达性分析
> 算法思想是通过一系列称为**GC Roots**的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，证明此对象是不可用的。哪些可以作为GC Roots的根：
* 虚拟机栈（栈帧中的局部变量区，也叫局部变量表）中引用的对象
* 本地方法栈中JNI（native方法）引用的对象
* 方法区中的类静态属性引用的对象
* 方法区中常量引用的对象

#### 如何枚举根节点：
以上引用作用GC Roots的根，如果**方法区很大，要逐个检查这里面的引用，那么必然会消耗很多时间**，而且枚举根节点需要停顿的。在HotSpot的实现中，是使用一组称为**OopMap的数据结构**来达到这个目的的，在类加载完成的时候，**HotSpot就把对象内什么偏移量是什么类型的数据计算出来**，在JIT编译过程中，**也会在特定的位置记录下栈和寄存器中哪些位置是引用**。这样，GC在扫描时就可以直接得这心信息了。

但一个很现实的问题：**可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那么会需要大量的额外空间，这样GC成本很高，安全点由此而来**。

实际上，在JIT编译过程中，在**特定的位置记录下栈和寄存器哪些位置是引用**，实际上这些位置就是**安全点**，意思就是说，**程序执行时并非在所有地方都能停顿下来开始GC，只有在达到安全点时才能暂停**。

Safepoint机制保证了程序执行时，在**不太长的时间内就会遇到可进入GC的Safepoint**，但**如果线程处于Sleep或者Blocked状态**，这时候线程**无法响应JVM的中断请求**，JVM也显然不太可能等待线程重新被分配CPU时间，这种情况就需要**安全域**来解决。**安全域是指在一段代码片段中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。这时候安全点就被扩展到了Safe Region**。

#### 垃圾回收器
![垃圾回收器-DSVRAO](https://gitee.com/dreamcater/blog-img/raw/master/uPic/垃圾回收器-DSVRAO.png)
#####  **CMS垃圾收集器**
> 一种以获取最短回收停顿时间为目标的收集器，是HotSpot虚拟机第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。CMS收集器是一种**标记-清除**算法实现的，整个过程分为四个步骤：
- 初始标记：暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- 并发标记：同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- 重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- 并发清除：开启用户线程，同时 GC 线程开始对为标记的区域做清扫。
> 从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**

> 为了解决以上问题，G1出现了

## 类加载过程
> 加载->验证->准备->解析->初始化
![类加载](https://gitee.com/dreamcater/blog-img/raw/master/uPic/类加载过程-5A2XIO.png)
### 加载
> 类加载过程的第一步，主要完成下面3件事情：
  * 通过**全类名**获取定义此类的**二进制字节流**
  * 将字节流所代表的**静态存储结构**转换为方法区的**运行时数据结构**
  * 在内存中生成一个代表该类的**Class对象**作为**方法区这些数据的访问**

### 验证
* 文件格式验证：主要验证class文件**是否规范**等
* 元数据验证：对于字节码描述的信息**语义分析**等
* 字节码验证：确保语义是ok的
* 符号引用验证：确保解析动作能执行

### 准备
> **准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意:
 * 这时候进行内存分配的仅包括**类变量(static)**,而不包括实例变量，实例变量会在对象实例化时对着对象一块分配在Java堆中
 * 这里所设置的初始值通常情况下是数据类型默认的**零值**（如0，0L,NULL,false等），比如我们定义了`public static int value=111` ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会复制）。特殊情况：比如给 value 变量加上了 **fianl 关键字**`public static final int value=111` ，那么准备阶段 value 的值就被复制为 111。

### 解析
> 解析阶段是虚拟机将常量池内的**符号引用替换为直接引用**的过程，也就是得到**类或者字段、方法在内存中的指针或偏移量**

### 初始化
> 初始化是类加载的最后一步，也是真正执行类中定义的**Java程序代码**（字节码），初始化阶段是执行**类构造器**`<clinit>()`方法的过程

## 类加载器
* BootstrapClassLoader（启动类加载器）：最顶层的加载类，由C++实现，负责加载`%JAVA_HOME%/lib`目录下的jar包和类或者或被 `-Xbootclasspath`参数指定的路径中的所有类。
* ExtensionClassLoader（扩展类加载器）：主要负责加载目录 `%JRE_HOME%/lib/ext` 目录下的jar包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的jar包。
* AppClassLoader（应用程序类加载器）

## 双亲委派模型
> 每一个类都有一个对应它的类加载器。系统中的ClassLoader在协同工作的时候会默认使用双亲委派模型。即在加载类的时候，**系统会首先判断当前类是否被加载过**。已经被加载的类会直接返回，否者才会尝试加载。加载的时候，首先会把该请求**委派该父类加载器**的`loadClass()`处理，因此所有的请求最终都应该传送到顶层的启动类加载器`BootstrapClassLoader`中。当父类加载器无法处理时，才由自己处理。
![类加载器](https://gitee.com/dreamcater/blog-img/raw/master/uPic/类加载器-Z1WdFt.png)

### 双亲委派模型的好处
* 保证了Java程序的稳定运行，可以避免类的重复加载，也保证了核心API不被篡改。
### 如何打破双亲委派模型
> 需要重写ClassLoader类的loadClass()方法：


## 类文件结构
```java
ClassFile {
    u4             magic; //Class 文件的标志
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问标记
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//Class 文件的字段属性
    field_info     fields[fields_count];//一个类会可以有个字段
    u2             methods_count;//Class 文件的方法数量
    method_info    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}
```

## 静态常量池
* 字面量
* 符号引用
  * 类和接口的全限定名
  * 字段的名称和描述符
  * 方法的名称和描述符
* 好处：**常量池是为了避免频繁创建和销毁对象而影响系统性能，其实现了对象的共享**

## 运行时常量池
> 当Class文件被加载完成后，java虚拟机会将静态常量池里的内容转移到运行时常量池里，在静态常量池的**符号引用有一部分是会被转变为直接引用的**，比如**类的静态方法或私有方法，实例构造方法，父类方法**，这是因为这些方法不能被重写其他版本，所以能在加载的时候就可以将符号引用转变为直接引用，而其他的**一些方法是在这个方法被第一次调用的时候才会从符号引用转变为直接引用**

## 字符串常量池
> 字符串常量池的存在使得JVM提高了性能和减少了内存开销
* 每当我们使用字面量`String s = '1'`创建字符串常量时，JVM首先会检查字符串常量池，如果该字符串已经存在常量池中，那么就将此字符串对象的地址赋值给引用s（引用s在Java栈）如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中，并将此字符串对象的地址赋值给引用s
* 每当我们使用关键字new（String s=new String(”1”);）创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么不再在字符串常量池创建该字符串对象，而直接堆中创建该对象的副本，然后将堆中对象的地址赋值给引用s，如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中，然后在堆中创建该对象的副本，然后将堆中对象的地址赋值给引用s。

## 版本变化
### 1.6

- 静态常量池在Class文件中。
- 运行时常量池在Perm Gen区(也就是方法区)中。
- 字符串常量池在运行时常量池中。

### 1.7

- 静态常量池在Class文件中。
- 运行时常量池依然在Perm Gen区(也就是方法区)中。在JDK7版本中，永久代的转移工作就已经开始了，将譬如符号引用转移到了native heap；字面量转移到了java heap；类的静态变量转移到了java heap。但是运行时常量池依然还存在，只是很多内容被转移，其只存着这些被转移的引用。
- 字符串常量池被分配到了Java堆的主要部分。也就是字符串常量池从运行时常量池分离出来了。

### 1.8
- 静态常量池在Class文件中。
- JVM已经将运行时常量池从方法区中移了出来，在Java 堆（Heap）中开辟了一块区域存放运行时常量池。同时永久代被移除，以元空间代替。元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。其主要用于存放一些元数据。
- 字符串常量池存在于Java堆中。

## 逃逸分析
> 逃逸分析的基本行为就是分析**对象动态作用域**；当**一个对象在方法中被定义后，它可能被外部方法引用，例如作为调用参数传递到其他方法中，成为方法逃逸。甚至还有可能被外部线程访问到，譬如赋值个类变量或可以在其他县城中访问的实例变量，成为线程逃逸**。如果能证明**一个对象不会逃逸到线程或方法之外，也就是别的方法或线程无法通过任何途径访问到这个对象**，则可能为这个变量进行一些高效的优化

### 栈上分配
> 如果确定一个对象不会逃逸出方法之外，那让这个对象在栈上分配内存将不错，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那**大量的对象就会随着方法的结束而自动销毁了**，垃圾收集系统的压力将会小很多。
### 同步消除
> **线程同步本身是一个相对耗时的过程**，**如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问**，那这个变量的**读写肯定就不会有竞争**，对这个变量实施的同步措施也就可以消除。
### 标量替换
> 标量是指一**个数据已经无法再分解成更小的数据来表示了**，Java虚拟机的原始数据类型都不能再进一步分解，它们就可以称为标量。如果逃逸分析证明**一个对象不会被外部访问**，并且**这个对象可以被拆散的话**，那程序真正执行的时候将**可能不创建这个对象**，而改**为直接创建它的若干个被这个方法使用的成员变量来代替**。除了可以让对象的成员变量在栈上（栈上存储的数据，有很大的概率会被虚拟机分配到物理机器高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。