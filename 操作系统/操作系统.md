# 操作系统
## 1. 线程与进程
### 进程与线程的区别：
* 根本区别： 进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位
* 资源开销:  每个进程都有独立的代码和数据空间(程序上下文)，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间；每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小
* 内存分配： 同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的
* 包含关系： 如果一个进程内有多个线程，则执行过程不是一条线，而是多条线（线程）共同完成的；线程是进程的一部分
* 与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程

### 协程
> 协程是一种用户态的轻量级线程，server的发展如下：IO密集型应用：多进程 -> 多线程 ->事件驱动 ->协程 
> 协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，然后去做其他工作，当你的IO解除之后切回原来的状态，恢复先前保存的寄存器上下文和栈。
#### 优点：
* 跨平台
* 无需线程上下文切换的开销
* 无需原子操作锁定及同步的开销
* 方便切换控制流，简化流程模型
* 高并发+高扩展行+低成本： 一个CPU支持上万的协程都不是问题，所以很适合用于高并发处理

#### 缺点：
* 无法利用多核资源：协程本质是一个单线程，他不能同时将单个CPU的多个核作用上，协程需要和进程配合才能运行在多CPU上.
* 进行阻塞(Blocking)操作会阻塞到整个程序; 这一点和事件驱动一样，可以使用异步IO操作来解决

## 2. 进程间通信
> 首先要知道进程之间为什么要通信。 进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源（例如打开的文件描述符）。 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程之间的通信。
### 进程通信的目的
* 数据传输：一个进程需要将它的数据发送给另一个进程
* 通知事件： 一个进程需要向另一个或一组进程发送消息，通知它（们）发生了某种事件
* 资源共享： 多个进程之间共享同样的资源，为了做到这一点需要内核提供互斥和同步机制
* 进程控制： 有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

### 通信方式
#### 管道
* 普通管道： 通常有两种限制，一种是单工，只能单向传输；二是只能在父子或兄弟进程间使用
* 流管道： 去除了第一种限制，为半双工，但依然智能在父子或兄弟进程间使用，可以双向传输
* 命名管道：去除了第二种限制,可以在许多并不相关的进程之间进行通讯

#### 信号量
* 信号量是一个计数器，可以用来控制多个进程对共享资源的访问
* 常作为一种锁机制，防止某个进程正在访问共享资源时，其他进程也访问
* 因此主要作为进程间基统一进程内不同线程的同步手段

#### 消息队列
> 消息队列是由消息构成的链表，存放在内核中并由消息队列标识符标识。消息对垒克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

#### 信号
> 信号是一种比较复杂的通信方式，用于通知接收某个事件已经发生。

#### 共享内存
> 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。
> 共享内存是最快的IPC方式，它是针对其他进程间通过新方式运行效率低而专门设计的
> 常常与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

* 共享内存的实现(mmap)
  
  > mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。
* 系统调用mmap共享内存的两种方式
  *  使用普通文件提供的内存映射：适用于任何进程之间；
  *  使用特殊文件提供匿名内存映射：适用于具有亲缘关系的进程之间； 由于父子进程特殊的亲缘关系，在父进程中先调用mmap()，然后调用fork()。那么在调用fork()之后，子进程继承父进程匿名映射后的地址空间，同样也继承mmap()返回的地址，这样，父子进程就可以通过映射区域进行通信了。

#### Socket
> 这是一种更为一般的进程间通信机制，可用于网络中不同机器之间的进程间通信，应用非常广泛

### 线程之间的通信
* 锁机制： 包括互斥锁、条件变量、读写锁等
* 信号量机制（SemaPhore）：包括无名线程信号量和命名线程信号量
* 信号机制（Signal）：类似进程间的信号处理
> 线程间通信的主要目的是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制

## 3. 系统进程调度
* **FCFS（先来先服务，队列实现，非抢占的）**：先请求CPU的进程先分配到CPU
* **SJF（最短作业优先调度算法）**：平均等待时间最短，但难以知道下一个CPU区间长度
* **优先级调度算法（可以是抢占的，也可以是非抢占的）**：优先级越高越先分配到CPU。相同优先级先到先服务。存在的问题是： 低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化
* **时间片轮转调度算法(可抢占的)**：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。
* **多级队列调度算法**：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。
* **多级反馈队列调度算法**：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。

## 4. 虚拟内存
### 为什么引进虚拟内存？
> 直接让一个进程全部放在主内存当中太占用内存，从前的计算机内存不大，因此在进程和主内存之间存在虚拟内存

### 虚拟内存的主要思想：
- 每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。
- 这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。
- 当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上。

## 5. 操作系统内存管理方式
### 分页管理
> 分页存储管理是将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页加以编号
> 优缺点：
  
  * 没有外部碎片，内存利用率高。但各页中内容没有关联，不利于编程和共享

### 分段管理
> 程序通过分段(segmentation)划分为多个模块，如代码段、数据段、共享段。内存每段的大小都匹配程序段，不会产生内部碎片。
> 优缺点：
  
  *  可以针对不同类型的段采取不同的保护。 可以按段为单位来进行共享，包括通过动态链接进行代码共享。 **不会产生内部碎片，但会产生外部碎片，内存利用率比分页低**。

### 段页式管理
> 一个进程中所包含的具有独立逻辑功能的程序或数据仍被划分为段，并有各自的段号s
> 优缺点：
  
  *  既有具有独立逻辑功能的段，又以大小相同的页为内存分配单位进而不会产生外部碎片。但仍会有内部碎片。

## 6. 死锁的条件
### 四个因素：
* **互斥条件**：该资源同一时刻只能被一个线程占有
* **请求与保持条件**： 一个进程因请求资源而堵塞时，对已获得的资源保持不放
* **不剥夺条件**：线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
* **循坏等待条件**： 若干进程之间形成一种头尾相接的循环等待资源关系

### 解决死锁的方式：
* 预防死锁
  * 资源一次性分配：破坏请求与保持条件
  * 可剥夺资源：当进程新申请的资源不满足时，释放已经分配的资源。破坏不可剥夺条件
  * 资源有序分配: 系统给进程编号，按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

* 避免死锁： 银行家算法：分配资源前先评估风险，会不会在分配后导致死锁
* 检测死锁： 建立资源分配表和进程等待表
* 解除死锁： 可以直接撤销死锁进程，或撤销代价最小的进程