# MySQL
## 1. MySQL的执行
### SQL执行顺序
> `from--where-group by--having --select--order by`

### MySQL是如何执行一条SQL语句的
![MlS1d5](https://gitee.com/dreamcater/blog-img/raw/master/uPic/SQL执行的全部过程-MlS1d5.png)
#### MySQL内部可以分为服务层和数据引擎层两部分
* **服务层包括连接器、查询缓存、分析器、优化器、执行器**等：涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
* **存储引擎负责数据的存储和提取**：其架构是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的是InnoDB，他从MySQL5.5.5版本开始成为了默认的存储引擎。
  
#### Server层按顺序执行SQL的步骤为：
客户端请求：
* **连接器**：验证用户身份，给予权限
* **查询缓存**：存在缓存则直接返回，不执行后续操作
* **分析器**：对SQL进行词法分析和语法分析操作
* **优化器**：主要对执行的SQL优化选择最优的执行方案
* **执行器**：执行时首先确认用户是否有执行权限，有才去使用这个引擎提供的接口
* **去引擎层获取数据返回**：如果开启查询缓存则会缓存查询结果

## 2. InnoDB和MyISAM
### MySQL的引擎都有哪些？
> MySQL内部可以分为服务和数据引擎层两部分。**服务层包括连接器、分析器、优化器、执行器、查询缓存等；数据引擎负责数据的存储和提取**。我说一下我了解的InnoDB和MyISAM。

### InoDB
* 是MySQL默认的事务型存储引擎，只有在需要它不支持的特性时，才会考虑使用其他存储引擎
* 实现了四个标准的隔离级别，默认级别是**可重复读（REPEATABLE READ）**。在可重复读隔离级别下，通过**多版本并发控制（MVCC）+（Next-Key Locking）防止幻影读**
* 主索引是**聚簇索引，在索引中保存了数据**，从而避免直接读取磁盘，因此对查询性能有很大的提升
* 内部做了很多优化，包括从磁盘读取数据时采用的**可预测性读**、能够加快读操作并且自动创建**自适应哈希索引**、能够加速插入操作的**插入缓冲区**等。
* 支持真正的**在线热备份**，。

### MyISAM
* 设计简单，数据以**紧密格式存储**。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它
* 提供了大量的特性，包括**压缩表、空间数据索引**等
* **不支持事物**
* **不支持行级锁，只能对整张表加锁**

### 索引文件
#### MyISAM
* **索引文件和数据文件是分离**的，索引文件仅保存数据记录的地址，同样使用B+树作为索引结构，叶节点的**data域存放的是数据记录的地址**
* 主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复
* MyISAM中索引检索的算法为**首先按照B+Tree搜索算法搜索索引**，**如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录**

#### InnoDB
* 数据文件本身就是索引文件，这棵树的叶节点**data域保存了完整的数据记录**（聚焦索引）
* 辅助索引data域存储相应记录主键的值而不是地址
* **聚集索引这种实现方式使得按主键的搜索十分高效**，**但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录**。

## 3. ACID
### ACID分别是什么
> 分别是**原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)和持久性(Duration)**

#### 原子性
> 原子性是指一个事物是一个不可分割的工作单位，**其中的操作要么都做，要么都不做**

#### 一致性
> 事物执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的。**满足所定义的状态，数据就是一致的，不满足这个状态，数据就是不一致的了**

#### 隔离性
> 多个事务并发执行的时候，事务内部的操作与其他事务是隔离的

#### 持久性
> 事务一旦提交，它对数据库的改变就是永久性的

### 并发事务带来的问题
> 脏读、不可重复读和幻读、丢弃修改
#### 脏读
> 第一个事务首先读取变量为50，接着准备更新为100的时，并未提交，第二个事务已经读取为100，此时第一个事务做了回滚。最终第二个事务读取的变量和数据库的不一样。

#### 丢弃修改
> T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，**T2 的修改覆盖了 T1 的修改**

#### 不可重复读
> T2 读取一个数据，T1 对该数据做了修改并提交。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

#### 幻读
> T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同。（和不可重复读的区别：一个是变量变化，一个是范围变化）

### 数据库的隔离级别
> MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ**（可重读）;与 SQL 标准不同的地方在于InnoDB 存储引擎在 REPEATABLE-READ（可重读）事务隔离级别 下使用的是**Next-Key Lock 锁**算法，因此可以避免幻读的产生
>  已经可以完全保证事务的隔离性要 求，即达到了 SQL标准的SERIALIZABLE(可串行化)隔离级别。

#### 未提交读
> 事务中发生了修改，即使没有提交，其他事务也是可见的,**可能会导致脏读、幻读或不可重复读**

#### 提交读
> 对于一个事务从开始直到提交之前，所做的任何修改对于其他事务都是不可见的。**可以阻止脏读，但是幻读和不可重复读仍有可能发生**

#### 可重复读
就是对一个记录读取多次的记录是相同的**可以阻止脏读和不可重复读，但幻读仍有可能发生**

#### 可串行读
在并发情况下，和串行化的读取的结果是一致的，没有什么不同；**该级别可以防止脏读、不可重复读以及幻读**

## 4. MySQL的日志文件
### **undoLog（回滚日志文件）**：
* **回滚日志文件** 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看。由**引擎层的InnoDB引擎实现**,是**逻辑日志**
### **redoLog（重做日志文件）**：
* **记录数据修改之后的值**，**用于持久化到磁盘中**。redo log包括两部分：**一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的**；二是**磁盘上的重做日志文件(redo log file)**，该部分日志是持久的。由引**擎层的InnoDB引擎实现**,是**物理日志**

### **binlog由**
* Mysql的Server层实现**,是**逻辑日志**,记录的是sql语句的原始逻辑**