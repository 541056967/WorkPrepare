# MySQL
## 1. MySQL的执行
### SQL执行顺序
> `from--where-group by--having --select--order by`

### MySQL是如何执行一条SQL语句的
![MlS1d5](https://gitee.com/dreamcater/blog-img/raw/master/uPic/SQL执行的全部过程-MlS1d5.png)
#### MySQL内部可以分为服务层和数据引擎层两部分
* **服务层包括连接器、查询缓存、分析器、优化器、执行器**等：涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
* **存储引擎负责数据的存储和提取**：其架构是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的是InnoDB，他从MySQL5.5.5版本开始成为了默认的存储引擎。
  
#### Server层按顺序执行SQL的步骤为：
客户端请求：
* **连接器**：验证用户身份，给予权限
* **查询缓存**：存在缓存则直接返回，不执行后续操作
* **分析器**：对SQL进行词法分析和语法分析操作
* **优化器**：主要对执行的SQL优化选择最优的执行方案
* **执行器**：执行时首先确认用户是否有执行权限，有才去使用这个引擎提供的接口
* **去引擎层获取数据返回**：如果开启查询缓存则会缓存查询结果

## 2. InnoDB和MyISAM
### MySQL的引擎都有哪些？
> MySQL内部可以分为服务和数据引擎层两部分。**服务层包括连接器、分析器、优化器、执行器、查询缓存等；数据引擎负责数据的存储和提取**。我说一下我了解的InnoDB和MyISAM。

### InoDB
* 是MySQL默认的事务型存储引擎，只有在需要它不支持的特性时，才会考虑使用其他存储引擎
* 实现了四个标准的隔离级别，默认级别是**可重复读（REPEATABLE READ）**。在可重复读隔离级别下，通过**多版本并发控制（MVCC）+（Next-Key Locking）防止幻影读**
* 主索引是**聚簇索引，在索引中保存了数据**，从而避免直接读取磁盘，因此对查询性能有很大的提升
* 内部做了很多优化，包括从磁盘读取数据时采用的**可预测性读**、能够加快读操作并且自动创建**自适应哈希索引**、能够加速插入操作的**插入缓冲区**等。
* 支持真正的**在线热备份**，。

### MyISAM
* 设计简单，数据以**紧密格式存储**。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它
* 提供了大量的特性，包括**压缩表、空间数据索引**等
* **不支持事物**
* **不支持行级锁，只能对整张表加锁**

### 索引文件
#### MyISAM
* **索引文件和数据文件是分离**的，索引文件仅保存数据记录的地址，同样使用B+树作为索引结构，叶节点的**data域存放的是数据记录的地址**
* 主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复
* MyISAM中索引检索的算法为**首先按照B+Tree搜索算法搜索索引**，**如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录**

#### InnoDB
* 数据文件本身就是索引文件，这棵树的叶节点**data域保存了完整的数据记录**（聚焦索引）
* 辅助索引data域存储相应记录主键的值而不是地址
* **聚集索引这种实现方式使得按主键的搜索十分高效**，**但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录**。

## 3. ACID
### ACID分别是什么
> 分别是**原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)和持久性(Duration)**

#### 原子性
> 原子性是指一个事物是一个不可分割的工作单位，**其中的操作要么都做，要么都不做**

#### 一致性
> 事物执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的。**满足所定义的状态，数据就是一致的，不满足这个状态，数据就是不一致的了**

#### 隔离性
> 多个事务并发执行的时候，事务内部的操作与其他事务是隔离的

#### 持久性
> 事务一旦提交，它对数据库的改变就是永久性的

### 并发事务带来的问题
> 脏读、不可重复读和幻读、丢弃修改
#### 脏读
> 第一个事务首先读取变量为50，接着准备更新为100的时，并未提交，第二个事务已经读取为100，此时第一个事务做了回滚。最终第二个事务读取的变量和数据库的不一样。

#### 丢弃修改
> T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，**T2 的修改覆盖了 T1 的修改**

#### 不可重复读
> T2 读取一个数据，T1 对该数据做了修改并提交。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

#### 幻读
> T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同。（和不可重复读的区别：一个是变量变化，一个是范围变化）

### 数据库的隔离级别
> MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ**（可重读）;与 SQL 标准不同的地方在于InnoDB 存储引擎在 REPEATABLE-READ（可重读）事务隔离级别 下使用的是**Next-Key Lock 锁**算法，因此可以避免幻读的产生
>  已经可以完全保证事务的隔离性要 求，即达到了 SQL标准的SERIALIZABLE(可串行化)隔离级别。

#### 未提交读
> 事务中发生了修改，即使没有提交，其他事务也是可见的,**可能会导致脏读、幻读或不可重复读**

#### 提交读
> 对于一个事务从开始直到提交之前，所做的任何修改对于其他事务都是不可见的。**可以阻止脏读，但是幻读和不可重复读仍有可能发生**

#### 可重复读
就是对一个记录读取多次的记录是相同的**可以阻止脏读和不可重复读，但幻读仍有可能发生**

#### 可串行读
在并发情况下，和串行化的读取的结果是一致的，没有什么不同；**该级别可以防止脏读、不可重复读以及幻读**

## 4. MySQL的日志文件
### **undoLog（回滚日志文件）**：
* **回滚日志文件** 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看。由**引擎层的InnoDB引擎实现**,是**逻辑日志**
### **redoLog（重做日志文件）**：
* **记录数据修改之后的值**，**用于持久化到磁盘中**。redo log包括两部分：**一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的**；二是**磁盘上的重做日志文件(redo log file)**，该部分日志是持久的。由**引擎层的InnoDB引擎实现**,是**物理日志**

### **binlog（逻辑日志文件）**
* Mysql的Server层实现,是**逻辑日志**,记录的是sql语句的原始逻辑，比如"把id='B' 修改为id = ‘B2’。binlog会写入指定大小的物理文件中，是追加写入的，当前文件写满则会创建新的文件写入。 产生:**事务提交的时候,一次性将事务中的sql语句,按照一定的格式记录到binlog中。用于复制和恢复在主从复制中，从库利用主库上的binlog进行重播(执行日志中记录的修改逻辑),实现主从同步。业务数据不一致或者错了，用binlog恢复**。 

MVCC多版本并发控制是MySQL中基于**乐观锁理论实现隔离级别**的方式，用于**读已提交和可重复读**取隔离级别的实现。在MySQL中，会在表中每一条数据后面添加两个字段：**最近修改该行数据的事务ID**，**指向该行（undolog表中）回滚段的指针**。**Read View判断行的可见性，创建一个新事务时，copy一份当前系统中的活跃事务列表。意思是，当前不应该被本事务看到的其他事务id列表**。

### binlog和redolog的区别
* redolog是在InnoDB存储引擎产生，而binlog是由MySQL数据库的上层服务层产生的
* 两种日志记录的内容形式不同，binlog是逻辑日志，记录的是对应的SQL语句；而InnoDB存储引擎层面的redolog是物理日志。
* 两种日志与记录写入磁盘的时间点不同，**binlog日志只在事务提交完成后进行一次写入**。而**innodb存储引擎的重做日志在事务进行中不断地被写入，并日志不是随事务提交的顺序进行写入的**。
* binlog不是循环使用，在写满或重启之后，会生成新的binlog文件，redolog是循环使用
* **binlog可以作为恢复数据使用，主从复制搭建**，**redolog作为异常宕机或者介质故障后的数据恢复使用**。

### MVC（多版本并发控制）的缺点
> MVCC在大多数情况下代替了行锁，实现了对读的非阻塞，读不加锁，读写不冲突。缺点是每行记录**都需要额外的存储空间，需要做更多的行维护和检查工作**。 要知道的，MVCC机制下，会在更新前建立undo log，根据各种策略读取时非阻塞就是MVCC，undo log中的行就是MVCC中的多版本。 而undo log这个关键的东西，**记载的内容是串行化的结果，记录了多个事务的过程，不属于多版本共存**。 这么一看，似乎mysql的mvcc也并没有所谓的多版本共存

### 读写分离原理
> 主库（master）将变更写**binlog**日志，然后从库（slave）连接到主库之后，从库有一个**IO线程**，将主库的binlog日志**拷贝到自己本地**，写入一个中继日志中。接着从库中有一个SQL线程会从中继日志读取binlog，然后执行binlog日志中的内容，也就是在自己本地再次执行一遍SQL，这样就可以保证自己跟主库的数据是一样的。
这里有一个非常重要的一点，就是从库同步主库数据的过程是**串行化**的，也就是说**主库上并行**的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行SQL的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。
而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。
所以mysql实际上在这一块有两个机制，一个是**半同步复制**，用来解决主库数据丢失问题；一个是**并行复制**，用来解决主从同步延时问题。
所谓并行复制，指的是从库**开启多个线程，并行读取relay log中不同库的日志**，然后并行重放不同库的日志，这是库级别的并行。

## 5. 索引
### 索引类型
* **FULLTEXT**：全文索引，目前只有MyISAM引擎支持，其可以在`CREATE TABLE ，ALTER TABLE ，CREATE INDEX`使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。
- HASH：由于HASH的唯一及类似键值对的形式，很适合作为索引。 HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。
- BTREE：BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。
- RTREE：RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。 相对于BTREE，RTREE的优势在于范围查找。

### 索引种类
- 普通索引：仅加速查询
- 唯一索引：加速查询 + 列值唯一（可以有null）
- 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
- 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
- 全文索引：对文本的内容进行分词，进行搜索
- 索引合并：使用多个单列索引组合搜索
- 覆盖索引：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖
- 聚簇索引：表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)

### 索引结构
#### MyISAM
* MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址，同样使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址
* 在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复
* MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录

#### InnoDB
* InnoDB的数据文件本身就是索引文件，这棵树的叶节点data域保存了完整的数据记录（聚集索引）
* InnoDB的辅助索引data域存储相应记录主键的值而不是地址
* 聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

#### 为什么InnoDB索引是B+树
- Hash索引：Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描
- 二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表。
- 平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低。
- 红黑树：通过舍弃严格的平衡和引入红黑节点，解决了 AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多。
- B+树：在B树的基础上，**B+树相对于B树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少**；此外将叶节点使用指针连接成链表，范围查询更加高效。B+树的**非叶子节点不保存数据**，只保存**子树的临界值**（最大或者最小），所以同样大小的节点。

### 索引失效
> 查询什么时候不走**索引**：
1. **模糊查询 %like**
2. **索引列参与计算,使用了函数**
3. **非最左前缀顺序**
4. **where对null判断**
5. **where不等于**
6. or操作有至少一个字段没有索引
7. 需要回表的查询结果集过大（超过配置的范围）
8. **将打算加索引的列设置为NOT NULL，否则将导致引擎放弃使用索引而进行全表扫描**

### 索引最左
**索引最左原则：**
**举例子**：
如果索引列分别为A，B，C，顺序也是A，B，C：
- 那么查询的时候，如果查询【A】【A，B】 【A，B，C】，那么可以通过索引查询
- 如果查询的时候，采用【A，C】，那么C这个虽然是索引，但是由于中间缺失了B，因此C这个索引是用不到的，只能用到A索引
- 如果查询的时候，采用【B】 【B，C】 【C】，由于没有用到第一列索引，不是最左前缀，那么后面的索引也是用不到了
- 如果查询的时候，采用范围查询，并且是最左前缀，也就是第一列索引，那么可以用到索引，但是范围后面的列无法用到索引（比如，a>= 3 and b = 4 and c = 5; A走索引，bc不走）（比如，a = 3 and b >= 4 and c = 5; a和b走，c不走）
**组合索引的底层其实按照第一个索引排序，从排序里面查第二个索引，以此类推。如果第一个索引失效，或者没有经过第一个索引，后面没发在前面的基础上查询。**

### 为什么使用索引
- 通过创建唯一性索引，可以保证数据库表中每一行数据的**唯一性**。
- 可以大大加快数据的**检索速度**，这也是创建索引的最主要的原因。
- 帮助服务器**避免排序和临时表**。
- 将**随机IO变为顺序IO**。
- 可以**加速表和表之间的连接**，特别是在实现数据的参考完整性方面特别有意义。
但是使用索引要看一条准则---  那就是读写比例，我们知道索引的缺点：
- 当对表中的数据进行增加、删除和修改的时候，**索引也要动态的维护**，这样就降低了数据的维护速度。
- 索引需要**占物理空间**，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立簇索引，那么需要的空间就会更大。
- **创建索引和维护索引要耗费时间**，这种时间随着数据量的增加而增加
**你想，如果某个场景，发送10条请求，9条写，1条读。 加索引岂不是在浪费效率和空间？**

## 6. 数据库优化
> 一个是索引优化，一个是结构优化
### 三范式
* 第一范式：原子性、字段不可再分割
* 第二范式：确保数据库表中的每一列都和主键有关，而不能只与主键的某一部分有关
* 第三范式：所有非主键字段和主键字段之前不能产生传递依赖

### 反范式设计
* 反范式化就是为了性能和读取效率的考虑而适当的对数据库设计范式的要求进行违反，**而允许存在少量的数据冗余，也就是使用空间来换取（查询）时间**；比如举个例子：**比如订单表中应该保留当前购买商品的价格、商品的名称（商品的价格是会变动的，这很危险）**

### 范式和反范式化设计的优缺点
#### 范式
* 优点
  *  可以尽量的减少数据冗余
  *  范式化的更新操作比反范式化更快
  *  范式化的表通常比反范式化更小
* 缺点
  *  对于查询需要关联多个表
  *  更难进行索引的优化
#### 反范式
 * 优点
  * 可以减少表的关联
  * 可以更好的进行索引优化
* 缺点
  * 存在数据冗余和数据维护异常
  * 对数据修改需要更多的成本

#### 如何选择varchar和char类型
- varchar用于存储变长字符串，只占用的必要的存储空间。
- char类型是定长的，char类型的最大宽度为255
- 场景：varchar适用于存储很少被更新的字符串列；char适合存储长度近似的值，适合存储短字符串，适合存储经常更新的字符串

### 分库分表
* 垂直分表：也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“
* 垂直分库：垂直分库针对的是一个系统中的不同业务进行拆分，比如用户User一个库，商品Producet一个库，订单Order一个库。 切分后，要放在多个服务器上，而不是一个服务器上。
* 水平分表:针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。不建议采用。
* 水平分库分表：将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。

#### 分库分表带来的问题
1. **事务支持**
> 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。
2. **join**
> TODO 分库分表后表之间的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表， 结果原本一次查询能够完成的业务，可能需要多次查询才能完成。 粗略的解决方法： 全局表：基础数据，所有库都拷贝一份。 字段冗余：这样有些字段就不用join去查询了。 系统层组装：分别查询出所有，然后组装起来，较复杂。

**分库分表中间件：**
Mycat 和 ShardingSphere（包括 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar 3 款产品）。

## 7. MySQL的锁
### MyISAM
> MyISAM只有表锁，其中又分共享读锁和独占写锁
- MyISAM表的读操作，不会阻塞其他用户对同一个表的读请求，但会阻塞对同一个表的写请求。
- MyISAM表的写操作，会阻塞其他用户对同一个表的读和写操作。
- MyISAM表的读、写操作之间、以及写操作之间是串行的。

### InnoDB
- 对于UPDATE、DELETE、INSERT语句，Innodb会自动给涉及的数据集加排他锁（X）；对于普通SELECT语句，Innodb不会加任何锁。
```sql
//显示共享锁（S） ：
 SELECT * FROM table_name WHERE .... LOCK IN SHARE MODE
 //显示排他锁（X）：
 SELECT * FROM table_name WHERE .... FOR UPDATE.
```
- 记录锁（Record Locks）：记录锁是封锁记录，记录锁也叫行锁，注意：行锁是针对索引的，如果表中没有索引，那么就会锁整张表
- 间隙锁（GAP）对于键值在条件范围内但并不存在的记录，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。
- 临键锁（Next-Key Lock）：（Record Locks+GAP），锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。