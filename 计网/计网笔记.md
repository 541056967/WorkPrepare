# 计算机与网络笔记 
## 1. 网络模型
![分层模型-EiHhGW](https://gitee.com/dreamcater/blog-img/raw/master/uPic/分层模型-EiHhGW.png)

### 简要概括
* 物理层：底层数据传输，如网线、网卡标准
* 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址
* 网络层：定义IP编址，定义路由功能；如不同的数据转发
* 传输层：端到端数据传输的基本功能；如TCP、UDP
* 会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件
* 标识层：数据格式标识，基本压缩加密功能
* 应用层：各种应用软件，包括web应用

### 流程
- 在四层，既传输层数据被称作**段**（Segments）；
- 三层网络层数据被称做**包**（Packages）；
- 二层数据链路层时数据被称为**帧**（Frames）；
- 一层物理层时数据被称为**比特流**（Bits）。

### 常见的端口号和协议号
![常见端口号-PemUq1](https://gitee.com/dreamcater/blog-img/raw/master/uPic/常见端口号-PemUq1.png)

### 总结
- 网络七层模型是一个标准，而非实现。
- 网络四层模型是一个实现的应用模型。
- 网络四层模型由七层模型简化合并而来。

### ping命令基于哪一层协议的原理是什么？
ping命令基于网络层的命令，是基于ICMP协议工作的。

### ARP
ARP是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。
起初要通过广播发送一个ARP请求包，这个包里存放了其MAC地址的主机IP地址，由于广播的包可以被同一个链路上所有的主机或路由器接收，因此ARP的请求包也就会被这同一个链路上所有的主机和路由器进行解析。如果ARP请求包中的目标IP地址与自己的IP地址的一致，那么这个节点就将自己的MAC地址塞入ARP响应包返回给主机A。

## 2. DNS
### DNS的定义
**官方解释**：DNS（Domain Name System，域名系统），因特网上作为**域名和IP地址相互映射**的一个**分布式数据库**，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。

### DNS解析过程
![DNS解析过程-eiVd6a](https://gitee.com/dreamcater/blog-img/raw/master/uPic/DNS解析过程-eiVd6a.png)
- 请求一旦发起，若是chrome浏览器，先在浏览器找之前**有没有缓存过的域名所对应的ip地址**，有的话，直接跳过dns解析了，若是没有，就会**找硬盘的hosts文件**，看看有没有，有的话，直接找到hosts文件里面的ip

[字节问了修改hosts，浏览器会变吗？](https://blog.csdn.net/woshizhangliang999/article/details/51457864)

- 如果本地的hosts文件没有能的到对应的ip地址，浏览器会发出一个**dns请求到本地dns服务器**，**本地dns服务器一般都是你的网络接入服务器商提供**，比如中国电信，中国移动等。
- 查询你输入的网址的DNS请求到达本地DNS服务器之后，**本地DNS服务器会首先查询它的缓存记录**，如果缓存中有此条记录，就可以直接返回结果，此过程是**递归的方式进行查询**。如果没有，本地DNS服务器还要向**DNS根服务器**进行查询。
- 本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。
- 最后，本地DNS服务器向**域名的解析服务器**发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。

### DNS查询方式
#### 递归解析
当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式。**局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询**。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。
#### 迭代解析
当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析。局部DNS服务器不是自己向其他DNS服务器进行查询，**而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序**，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。

### DNS负载均衡
当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在**DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器**,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。

### 为什么域名解析用UDP协议？
因为UDP快啊！UDP的DNS协议只要一个请求、一个应答就好了。而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手。但是UDP协议传输内容不能超过512字节。不过客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。

### 为什么区域传送用TCP协议？
因为TCP协议可靠性好！你要从主DNS上复制内容啊，你用不可靠的UDP？ 因为TCP协议传输的内容大啊，你用最大只能传512字节的UDP协议？万一同步的数据大于512字节，你怎么办？

## 3. Http和Https
### GET和POST的区别
* GET使用URL或者Cookie传递参数，而POST将数据存放在BODY中
* GET方式提交的数据有长度限制，而POST的数据可以很大
* POST比GET方式安全，数据在地址栏上不可见
* **本质区别**：GET请求是幂等性的，POST请求不是。
  *  幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。
  *  因此不应该且**不能用get请求做数据的增删改这些有副作用的操作**。因为get请求是幂等的，**在网络不好的隧道中会尝试重试**。如果用get请求增数据，会有**重复操作**的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。

### 响应码 
#### `1XX` 信息
* **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

#### `2XX` 成功
* **200 OK**
* **204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
* **206 Partial Content** ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。
* 
#### `3XX` 重定向
- **301 Moved Permanently** ：永久性重定向
- **302 Found** ：临时性重定向
- **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
- **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
- **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

### `4XX` 客户端错误
- **400 Bad Request** ：请求报文中存在语法错误。
- **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
- **403 Forbidden** ：请求被拒绝。没有权限
- **404 Not Found**：路由不存在，或者没找到

### `5XX` 服务器错误
- **500 Internal Server Error** ：服务器正在执行请求时发生错误。
- **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

### HTTP首部

### Cookies
* HTTP 协议是**无状态**的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。
* Cookie 是**服务器发送到用户浏览器并保存在本地的一小块数据**，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。
* 用途：
  * 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
  * 个性化设置（如用户自定义设置、主题等）
  * 浏览器行为跟踪（如跟踪分析用户行为等）

### Session
* 除了可以将用户信息通过Cookies存储在用户浏览器中，也可以利用Session存储在服务器，存储在服务器端的信息更加安全
* Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。

### Cookies和Session的选择
- Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；
- Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
- 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

### JWT
#### JWT的定义
* **JWT(json web token)**是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。
* cookie+session这种模式通常是保存在**内存**中，而且服务从单服务到多服务会面临的session共享问题，随着用户量的增多，开销就会越大
* 而JWT不是这样的，**只需要服务端生成token，客户端保存这个token，每次请求携带这个token，服务端认证解析就可**。

#### JWT的构成
* 第一部分我们称它为**头部（header)**,第二部分我们称其为**载荷（payload)**，第三部分是**签证（signature)**

#### JWT的总结
* 因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。
* payload部分，JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。
* 便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。它不需要在服务端保存会话信息, 所以它易于应用的扩展。

### 浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？
* 在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，**某些服务器对 Connection: keep-alive 的 Header 进行了支持**。
* **持久连接**：既然维持 TCP 连接好处这么多，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。

### 一个TCP连接可以对应几个HTTP请求？
* 如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。

### 一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？
* HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。

### 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？
* 有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。

### 在浏览器中输入url地址后显示主页的过程?
- 根据域名，进行DNS域名解析；
- 拿到解析的IP地址，建立TCP连接；
- 向IP地址，发送HTTP请求；
- 服务器处理请求；
- 返回响应结果；
- 关闭TCP连接；
- 浏览器解析HTML；
- 浏览器布局渲染；

### `HTTPS`的定义
* HTTPS并不是新协议，而是让**HTTP先和SSL（Secure Socket Layer）通信，再由SSL和TCP通信，也就说说HTTPS使用了隧道进行通信**
* 通过使用SSL，HTTPS具备了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）

###  `HTTP`的缺点
* 使用明文进行通信，内容可能会被窃听
* 不验证通信方的身份，通信方的身份有可能遭遇伪装
* 无法验证报文的完整性，有可能被篡改

### 对称密钥/非对称密钥加密
#### 对称密钥
* 加密和解密使用同一个密钥
* 优点：运算速度快
* 缺点：无法安全地将密钥传输给通信方

#### 非对称密钥
* 又称公开密钥加密（public-key encryption），加密和解密使用不同的密钥
* 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥加密后，接收方收到内容后用私有密钥解密
* 有点：可以更安全地将公开密钥传输给通信方
* 缺点：运算速度慢

### HTTPS采用的加密方式

HTTPS 采用混合的加密机制，使用**非对称密钥加密用于传输对称密钥来保证传输过程的安全性**，之后使用**对称密钥加密进行通信来保证通信过程的效率**。DES+RSA
![rsa原理-rWg4oK](https://gitee.com/dreamcater/blog-img/raw/master/uPic/rsa原理-rWg4oK.png)
确保传输安全过程（其实就是rsa原理）：
* Client给出**协议版本号**、一个客户端生成的**随机数**（Client random），以及客户端支持的**加密方法**。
* Server确认双方使用的**加密方法**，并给出**数字证书**、以及一个服务器生成的**随机数**（Server random）。
* Client确认**数字证书有效**，然后生成一个新的**随机数**（Premaster secret），并使用**数字证书中的公钥，加密这个随机数**，发给Server。
* Server使用自己的**私钥，获取Client发来的随机数**（Premaster secret）。
* Client和Server根据约定的加密方法，使用前面的**三个随机数，生成”对话密钥”**（session key），用来加密接下来的整个对话过程。

### 认证
* 通过使用 **证书** 来对通信方进行认证。
* 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。
* 服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。
* 进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。
[加密全套流程](https://www.cnblogs.com/handsomeBoys/p/6556336.html)
[https://www.cnblogs.com/xdyixia/p/11610102.html](https://www.cnblogs.com/xdyixia/p/11610102.html)

### HTTPS的缺点
- 因为需要进行加密解密等过程，因此速度会更慢；
- 需要支付证书授权的高额费用。

## 4. TCP和UDP
### 4.1 TCP
#### TCP的定义
* `TCP（Transmission Control Protocol 传输控制协议）`是一种**面向连接的、可靠的、基于字节流的传输层通信协议**

#### TCP头部报文
* **sourec port和destination port**
  * 源端口好指本地端口，目的端口就是远程端口
  > 应用程序的端口号和应用程序所在主机的 IP 地址统称为 socket（套接字），IP:端口号, 在互联网上 socket 唯一标识每一个应用程序，源端口+源IP+目的端口+目的IP称为”套接字对“，一对套接字就是一个连接，一个客户端与服务器之间的连接。
* **Sequence Number**
  > 称为「序列号」。用于 TCP 通信过程中某一传输方向上字节流的每个字节的编号，为了确保数据通信的有序性，避免网络中乱序的问题。接收端根据这个编号进行确认，保证分割的数据段在原始数据包的位置。初始序列号由自己定，而后绪的序列号由对端的 ACK 决定：SN_x = ACK_y (x 的序列号 = y 发给 x 的 ACK)。
* **Acknowledge Number**
  > 称为「确认序列号」。确认序列号是接收确认端所期望收到的下一序列号。确认序号应当是上次已成功收到数据字节序号加1，只有当标志位中的 ACK 标志为 1 时该确认序列号的字段才有效。主要用来解决不丢包的问题。
* **TCP Flag**
`TCP` 首部中有 6 个标志比特，它们中的多个可同时被设置为 `1`，主要是用于操控 `TCP` 的状态机的，依次为`URG，ACK，PSH，RST，SYN，FIN`。
当然只介绍三个：
1. **ACK**：这个标识可以理解为发送端发送数据到接收端，发送的时候 ACK 为 0，标识接收端还未应答，一旦接收端接收数据之后，就将 ACK 置为 1，发送端接收到之后，就知道了接收端已经接收了数据。
2. **SYN**：表示「同步序列号」，是 TCP 握手的发送的第一个数据包。用来建立 TCP 的连接。SYN 标志位和 ACK 标志位搭配使用，当连接请求的时候，SYN=1，ACK=0连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有 SYN 的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口。
3. **FIN**：表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的 TCP 数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。发送端只剩最后的一段数据了，同时要告诉接收端后边没有数据可以接受了，所以用FIN标识一下，接收端看到这个FIN之后，哦！这是接受的最后的数据，接受完就关闭了；**TCP四次分手必然问**。
* **Window size**
> 称为滑动窗口大小。所说的滑动窗口，用来进行流量控制。

#### TCP三次握手
![TCP三次握手-2ujCx2](https://upload-images.jianshu.io/upload_images/4698491-8f2ded5fc9495bbd.JPG?imageMogr2/auto-orient/strip|imageView2/2/w/655/format/webp)
* **初始状态**：客户端处于`closed（关闭）`状态，服务器处于`listen(监听)`状态
* **第一次握手**：客户端发送请求报文将 `SYN = 1`同步序列号和初始化序列号`seq = x`发送给服务端，发送完之后客户端处于`SYN_Send`状态。
* **第二次握手**：服务端收到 `SYN` 请求报文之后，如果同意连接，会以自己的同步序列号`SYN(服务端) = 1`、初始化序列号 `seq = y`和确认序列号（期望下次收到的数据包）`ack = x + 1` 以及确认号`ACK = 1`报文作为应答，服务器为`SYN_Receive`状态。（问题来了，两次握手之后，所以老哥，你需要给我三次握手来传个话告诉我一声。你要是不告诉我，万一我认为你跑了，然后我可能出于安全性的考虑继续给你发一次，看看你回不回我。）
* **第三次握手**： 客户端接收到服务端的 `SYN + ACK`之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号 `ack = y + 1`和数据包的序列号 `seq = x + 1`以及确认号`ACK = 1`确认包作为应答，客户端转为`established`状态。（分别站在双方的角度上思考，各自ok）
  >1. 你吃饭了嘛？（seq=x），收到请回答（SYN=1）
  >2. 收到（ACK=1），吃饭了（ack=x+1），你吃饭了吗？（seq=y），收到请回答（SYN=1）
  >3. 收到（ACK=1），吃饭了（ack=y+1），那么我们聊一下接下里的事情（established）

### TCP四次分手
![TCP四次分手-Nt8NUx](https://gitee.com/dreamcater/blog-img/raw/master/uPic/TCP四次分手-Nt8NUx.png)
* **初始化状态**：客户端和服务端都在连接状态，接下来开始进行四次分手断开连接操作
* **第一次分手**：无论是client还是server都可以发起，因为TCP是全双工的
  > 假如客户端发送的数据已经发送完毕，发送FIN = 1 **告诉服务端，客户端所有数据已经全发完了**，**服务端你可以关闭接收了**，但是如果你们服务端有数据要发给客户端，客户端照样可以接收的。此时客户端处于FIN = 1等待服务端确认释放连接状态。
* **第二次分手**：Server接收到Client的释放请求连接之后，**知道Server没有数据发给自己了，于是发送ACK=1告诉Client收到了消息**，此时Server处于`CLOSE_WAIT`等待关闭状态。（服务端先回应给客户端一声，我知道了，但服务端的发送数据能力即将等待关闭，于是接下来第三次就来了。）
* **第三次分手**：此时服务端向客户端把所有数据传输完毕，发送一个FIN=1，**告诉客户端，服务端所有数据发送完毕，客户端可以关闭接收数据连接**了。此时服务端状态处于LAST_ACK状态，来等待确认客户端是否收到了自己的请求。（服务端等客户端回复是否收到呢，不收到的话，服务端不知道客户端是不是挂掉了还是咋回事呢）
* **第四次分手**：此时如果客户端收到了服务端发送完的信息之后，就发送ACK=1，告诉服务端，客户端已经接收到信息，**有一个2MSL的延迟等待**

#### 为什么要有2MSL等待延迟？
> 如果最后客户端发送的ACK=1丢失，服务端无法判断是否已经发送完数据，因此再次发起断开连接的请求，一个来回就是2MSL；
> 客户端给服务端发送的ACK = 1丢失，**服务端等待 1MSL没收到**，**然后重新发送消息需要1MSL**。如果再次接收到服务端的消息，则**重启2MSL计时器**，**发送确认请求**。客户端只需等待2MSL，如果没有再次收到服务端的消息，就说明服务端已经接收到自己确认消息；此时双方都关闭的连接，TCP 四次分手完毕

#### 为什么需要四次分手？
> 任何一方都可以在数据传输结束后发起连接释放的通知，待对方确认后进入半关闭状态。当对方也无数据再次发送时，则发出连接释放通知，对方确认后就完全关闭TCP连接。
> 举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

#### TCP粘包
> 指发送双方发送的若干包数据到接收端时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包的尾
> 产生原因：
- 由TCP**连接复用**造成的粘包问题。
- 因为TCP默认会使用**Nagle算法**，此算法会导致粘包问题。
  - 只有上一个分组得到确认，才会发送下一个分组；
  - 收集多个小分组，在一个确认到来时一起发送。
- **数据包过大**造成的粘包问题。
- 流量控制，**拥塞控制**也可能导致粘包。
- **接收方不及时接收缓冲区的包，造成多个包接收**
> 解决方法：
* **Nagle算法**问题导致的，需要结合应用场景适当关闭该算法
* 尾部标记序列。通过特殊标识符表示数据包的边界，例如\n\r，\t，或者一些隐藏字符。
* 头部标记分步接收。在TCP报文的头部加上表示数据长度。
* 应用层发送数据时**定长**发送。 

#### TCP 协议如何保证可靠传输？
- **确认和重传**：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。
- **数据校验**：TCP报文头有校验和，用于校验报文是否损坏。
- **数据合理分片和排序**：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。
- **流量控制**：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。
- **拥塞控制**：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。

### TCP 利用滑动窗口实现流量控制的机制？

>  流量控制是为了控制发送方发送速率，保证接收方来得及接收。TCP 利用滑动窗口实现流量控制。

TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着**接收方还有多大的缓冲区可以用于接收数据**。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据。

> 例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。

#### TCP拥塞控制的机制以及算法？
> 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。
TCP 发送方要维持一个 **拥塞窗口(cwnd) 的状态变量**。拥塞控制窗口的大小**取决于网络的拥塞程度**，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。TCP的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。

#### TCP的长连接和短连接
[https://www.cnblogs.com/chinaops/p/9303041.html](https://www.cnblogs.com/chinaops/p/9303041.html)

### 4.2 UDP
#### UDP的定义
> UDP 提供无连接的，尽最大努力传输数据的服务

#### UDP的特点
* 无连接
* 使用**尽最大努力交付**，即不保证可靠交付，因此主机不需要维持复杂的连接状态
* 面向报文的
* 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频等）
* 支持一对一、一对多、多对一和多对多的交互通信
* UDP的首部开销小，只有8个字节。比TCP首部的20个字节要短

#### TCP的特点
* 面向连接的
* 每一条TCP连接只能有两个端点，是点对点（一对一）
* 提供可靠交付的服务
* 提供全双工通信
* 面向字节流：TCP中的流（Stream）指的是流入进程或从进程流出的字节序列。
  > 虽然应用程序和TCP的交互是一次一个数据块，但TCP把应用程序交下来的数据仅仅看成是一连串无结构的字节流。
  