# Redis相关
## 1. Redis为什么快
* **完全基于内存**：大部分请求是纯粹的内存操作
* **合理的数据结构**：结构简单，操作也简单
* **单线程操作**：避免了频繁的上下文切换和竞争条件，不用考虑各种加锁从而降低消耗
* **使用多路I/O复用模型，非阻塞I/O**：利用`select、poll和epoll`可以监察检查多个流的I/O事件的能力，让多个线程高效的处理多个连接请求

## 2. Redis的数据结构
![数据结构](https://img2018.cnblogs.com/blog/1289934/201906/1289934-20190621163930814-1395015700.png)
> Redis中所有的key都是字符串

### 字符串类型
* 最基本的数据类型，一个key对应一个value
* String类型是二进制安全的，可以包含任何数据，例如数字、字符串、jpg图片或序列化的对象
* 使用：set,get,del,incr,decr等

### Hash
* 是一个HashMap，值本身就是一对kv
* Redis中的字典使用hash作为存储
* 使用MurrmurHash2算法来计算键的哈希值，使用链地址解决键冲突

### List
* 本质是一个链表，**微博关注列表、粉丝列表、消息列表等**都可以用List结构实现
* value可以重复，通过下标取出对应值，是一个双向链表
* `lrange`从某个元素开始读取多少个元素，基于List实现分页查询

### Set
* 与List类似，但是可以自动排重
* 不允许有重复元素，元素时无序的，不能通过下标获取
* 可以基于Set实现交集、并集、差集等操作

### Zset
* 有序集合，保留了集合不能有重复成员的特性，区别是，有序集合中的元素是可以排序的，它给每个元素设置一个分数，作为排序的依据。
* 有序集合中的元素不可以重复，但是score 分数 可以重复，就和一个班里的同学学号不能重复，但考试成绩可以相同）。

### 跳表
* 一种有序的数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问
* 平均O（logn），最坏O（N)
* 有层的概念，层带有前进指针和跨度

## 3. Redis的持久化
> RDB和AOF
### RDB
> **RDB**是一种**快照存储持久化**方式，具体是将`redis`某一时刻的内存数据保存到硬盘的文件当中，默认文件名为`dump.rdb`。在Redis服务器启动时，会重新加载`dump.rdb`文件的数据到内存中恢复数据
#### 优点：
* RDB会生成多个数据文件，**每个数据文件都代表了某一时刻中redis的数据**，这种多个数据文件的方式，非常适合**做冷备**
* RDB对redis对外提供读写服务的时候，影响非常小，因为redis主进程只需要fork一个子线程出来，让子进程对磁盘io化来进行rdb持久化
* **RDB在恢复大数据集时的速度比AOF的恢复速度要快**
#### 缺点：
* **如果redis要故障时要尽可能少的丢失数据，RDB没有AOF好**，例如1:00进行的快照，在1:10又要进行快照的时候宕机了，这个时候就会丢失10分钟的数据。
* RDB每次fork出子进程来执行RDB快照生成文件时，如果文件特别大，可能会导致客户端提供服务暂停数毫秒或者几秒

### AOF
> 把所有的**对Redis服务器进行修改的命令都存到一个文件里（命令的集合）**。使用AOF进行持久化，每一个写命令都通过write函数追加到`appendonly.aof`
#### 优点
* **AOF可以更好地保护数据不丢失，一般AOF每隔一秒进行一次fsync**，通过后台的一个线程去执行一次fsync操作，如果redis进程挂掉，最多丢失1秒的数据。
* AOF以appen-only的模式写入，所以没有任何磁盘寻址的开销，写入性能非常高
* AOF日志文件的命令通过非常可读的方式进行记录，非常适合做灾难性的误删除紧急恢复

#### 缺点：
* 对于同一份文件，AOF文件比RDB数据快照要大
* AOF开启后支持写的QPS会比RDB支持的写的QPS低，因为AOF一般会配置成每秒fsync操作，每秒的fsync操作还是很高
* **数据恢复比较慢，不适合做冷备**。

### 如何选择
> 用AOF来保证数据不丢失，作为恢复数据的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，使用RDB进行快速恢复。

### 冷备
* 冷备：备份系统未安装或未配置成与当前使用的系统相同或相似的运行环境，应用系统数据没有及时装入备份系统
* 温备：将备份系统已安装配置成与当前使用的系统相同或相似的系统和网络运行环境，安装应用系统业务定期备份数据。
* 热备：备份处于联机状态，当前应用系统通过高速通信线路将数据实时传送到备份系统，保持备份系统与当前应用系统数据的同步；也可定时在备份系统上恢复应用系统的数据

## 4. 内存淘汰机制
### 过期时间
* 定期删除：默认每隔100ms随机抽取设置了过期时间的key，如果过期删除
* 惰性删除：查询到key过期还未删除时就删除

### 内存淘汰机制
> 内存数据集大小上升到一定程度时，就会执行内存淘汰策略，共6种
* volatile-lru：从已经设置过期时间的数据集中挑选最少使用的数据淘汰
* volatile-ttl：从已经设置过期时间的数据集中挑选将要过期的数据淘汰
* volatile-random：从已经设置过期时间的数据集中任意选择数据淘汰
* alllkeys-lru：从数据集中挑选最少使用的数据淘汰
* alllkeys-random：从数据集中任意选择数据淘汰
* no-enviction：禁止驱逐数据。

## 5. 缓存穿透和雪崩
### 缓存穿透
> 恶意请求缓存中不存在的数据，导致所有请求落到数据库上，造成数据库短时承受大量请求而崩掉
> 解决方法：在接口做校验；存null值，布隆过滤器

### 缓存雪崩
> 缓存同一时间大面积的失效，所以后面的请求都落到数据库上
> 解决方法：采用高可用架构，给缓存失效时间加上一个随机值，限流降级策略

## 6. Redis分布式锁
> 通过`setnx`命令，`setnx`是`SET if not exists`(如果不存在，则 SET)的简写。
> 加锁：使用setnx key value命令，如果key不存在，设置value(加锁成功)。如果已经存在lock(也就是有客户端持有锁了)，则设置失败(加锁失败)。解锁：使用del命令，通过删除键值释放锁。释放锁之后，其他客户端可以通过setnx命令进行加锁。

## 7. Redis主从复制
> 主从刚刚连接的时候，进行全量同步（RDB）；全同步结束后，进行增量同步

### 心跳机制
> 在命令传播阶段，主从节点之间一直都需要进行信息互换，使用心跳机制进行维护，实现主从节点连接保持在线

## 8. Redis的缓存策略
### Cache Aside （旁路缓存）策略
> 更新数据库，更新缓存
* 写策略：先更新数据库，再更新缓存
* 读策略：读缓存，缓存缺失时查找数据库并返回

### Read/Write Through （同步直写）策略
> 用户只与缓存模块打交道，由缓存模块跟具体的缓存实现及数据库通信，写或读数据

### Write Behind （异步写回）策略
> 用户只与缓存模块打交道，由缓存模块跟具体的缓存实现及数据库通信，写或读数据
