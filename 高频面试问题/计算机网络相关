# 计算机网络相关面试题整理
## 网络模型
![分层模型-EiHhGW](https://gitee.com/dreamcater/blog-img/raw/master/uPic/分层模型-EiHhGW.png)
### 1. OSI七层模型
* 物理层：底层数据传输
* 数据链路层：定义数据的基本格式，如何传输和标识，如MAC地址
* 网络层：定义IP地址和路由功能，如不同设备的数据转发
* 传输层：端到端传输的基本功能，如TCP和UDP
* 会话层：控制应用程序之间的会话能力，如不同软件数据分发给不同软件
* 表示层：数据格式标识，基本压缩功能
* 应用层：各种应用软件，包括web应用
> 传输层数据称为段、网络层数据称为包、数据链路层数据称为帧、物理层称为比特流
### 总结
* 七层模型是一个标准而非实现
* 四层（TCP/IP）模型是一个实现的应用模型

### 2. ping命令的原理
* ping是基于网络层的命令，基于ICMP协议。ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。
* ping不能完全记录所经过的路由，traceroute可以。首先发一个TTL=1的报文，随后依次增加

### 3. ARP的原理
> 解决地址问题的协议，以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址

### 4. DNS
#### 定义
> Domain Name System(域名解析系统)，因特网上**域名和IP地址相互映射的一个分布式数据库**。通过主机名得到对应IP地址的过程叫做域名解析
#### 解析过程
![DNS解析过程-eiVd6a](https://gitee.com/dreamcater/blog-img/raw/master/uPic/DNS解析过程-eiVd6a.png)
* 请求顺序：本地dns-根dns-.com域服务器-xxx.com域名服务器
* 先在浏览器找之前有没有缓存过域名对应的ip地址，有的话直接跳过dns解析

#### DNS查询方式
* 递归解析
* 迭代解析：只能找到相关服务器，不会帮你去查
* **DNS负载均衡**：DNS服务器为同一个主机名配置多个IP地址，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器
* 为什么DNS用UDP？：UDP快
* 为什么区域传送用TCP？：TCP协议可靠性好

## TCP
### 5. TCP协议
#### 定义
> Transmission Control Protocol 传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议
#### TCP头部
![TCP头部](https://img-blog.csdn.net/20180501221501343?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE3NjExMjg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
* 16位源端口和16位目的端口号
  > 应用程序的端口号和应用程序所在主机的IP地址统称为socket（套接字），一个socket唯一标识一个应用程序
* 32位序列号（Sequence Number）
  > 用于TCP通信某一传输方向上字节流的每个字节编号，确保数据通信的有序性，避免乱序问题。接收端根据编号确认分割的数据段在原始数据包的位置。Sequence Number_x = Acknowledge Number_y（x的序列号=y发给x的确认号）
* 32位确认序列号（Acknowledge Number）
  > 接收端锁期望收到的下一序列号。接收端的确认序列号为上次成功收到的序列号+1，只有当标志位中的ACK为1时，确认序列号才有效，主要用来解决不丢包的问题
* 6位标志位TCP Flag
  > URG,ACK,PSH,RST,SYN,FIN
  * ACK:ACK位0表示接收端还未应答，一旦接收到收到数据之后，就将ACK置为1
  * SYN（同步序列号）：TCP握手发送的第一个数据包。当SYN=1，ACK=0连接被响应的时候，SYN=1，ACK=1.通常被用来进行端口扫描
  * FIN：表示发送端已经达到数据末尾，没有数据需要传输。发送FIN位标志的TCP数据包后，连接将被断开

#### Window Size
> TCP header中有一个Window Size字段，指接收端的窗口，即接收窗口，用来告知发送端本身所能接收的数据量，从而达到一部分流控的目的
> 为了得到最优的连接速率，使用TCP窗口来控制流速率，滑动窗口是一种主要机制。这个窗口容许源端在给定链接传送数据分段而不用等待目标端返回ACK
> 滑动的依据就是发送数据已经收到ACK，确认对端收到，才能继续窗口滑动发送新的数据。能够看到窗口大小对于吞吐量有着重要影响
> 发送到收到窗口为0时的报文，启动持续计数器，超市后重新发送零窗口探测报文

#### 拥塞控制
> 慢开始、拥塞避免、快重传、快恢复
##### 慢开始+拥塞避免
> 发送端维护一个拥塞窗口cwnd的状态变量，发送窗口swnd，慢开始门限ssthresh
> 发送方使用拥塞窗口为发送窗口 swnd = cwnd,每次收到确认报文段，有cwnd += 确认报文段数量
> 拥塞避免后，每次 cwnd +=1
> 报文丢失认为有拥塞， ssthresh变为当前cwnd一半，cwnd置为1，
* 当cwnd < ssthresh时，使用慢开始
* 当cwnd > ssthresh时，使用拥塞避免
* 当cwnd = ssthresh时，两中都可以

##### 快重传
* 接收端不要等待自己发送数据时才确认，而是立即发送确认
* 即使收到了失序的报文也要立即对已收到的确认
* 发送方一旦收到3个连续的重复确认，不等待超时重传计数器，立即重传

##### 快恢复
* ssthresh和cwnd变为当前窗口的一半
* 或者cwnd等于新的ssthresh+3

#### 三次握手
![TCP三次握手-2ujCx2](https://upload-images.jianshu.io/upload_images/4698491-8f2ded5fc9495bbd.JPG?imageMogr2/auto-orient/strip|imageView2/2/w/655/format/webp)

#### TCP四次分手
![TCP四次分手-Nt8NUx](https://gitee.com/dreamcater/blog-img/raw/master/uPic/TCP四次分手-Nt8NUx.png)

#### TCP的三次握手和四次挥手
* **为什么是三次握手**：为了防止已失效的连接请求报文段突然又传送到了服务端,TCP 需要seq序列号来做可靠重传或接收，而避免连接复用时无法分辨出 seq 是延迟或者是旧链接的 seq，因此需要三次握手来约定确定双方的 ISN（初始 seq 序列号）
* **为什么是四次挥手**：任何一方都可以在数据传输结束后发起连接释放的通知，待对方确认后进入半关闭状态。当对方也无数据再次发送时，则发出连接释放通知，对方确认后就完全关闭TCP连接。
* **为什么有2MSL的等待延迟**：如果最后客户端发送的ACK=1丢失，服务端无法判断是否已经发送完数据，因此再次发起断开连接的请求，一个来回就是2MSL
* **TIME_WAIT过多的危害及解决办法**：占用内存；修改TIME_WAIT相关参数(tw_reuse,te_recycle)

#### TCP粘包
* TCP是流传输协议,是一种面向连接的、可靠的、基于字节流的传输层通信协议
* TCP没有包的概念，它只负责传输字节序列，UDP是面向数据报的协议，所以不存在拆包粘包问题
* 由应用层来维护消息和消息的边界，即需要一个应用层协议，比如HTTP
> 解决方式：
* 消息长度固定，提前确定包长度，读取的时候也安固定长度读取，适合定长消息包。
* 使用特殊的字符或字符串作为消息的边界，例如 HTTP 协议的 headers 以“\r\n”为字段的分隔符
* 自定义协议，将消息分为消息头和消息体，消息头中包含表示消息总长度

#### TCP如何保证可靠传输
* 确认和重传
* 数据校验：报文头部有校验和，校验报文是否损坏
* 合理分片和排序
* 拥塞控制
* 流量控制

### 6. HTTP
#### HTTP的状态码
* **1xx 信息**：100 Continue 表明目前为止正常，客户端可以持续发送或忽略这个相应
* **2xx 成功**
  * 200：OK
  * 204：请求已成功处理，但是不返回数据
  * 206：客户端进行了范围请求，响应报文包含由Content-Range指定范围的实体内容
*  **3xx 重定向**
  * 301：永久重定向
  * 302：临时重定向
  * 303：和302类似，但明确由GET获取资源
  * 304：请求报文包含一些条件，不满足则返回304
  * 307：临时重定向，要求浏览器不会把POST改成GET
*  **4xx 客户端错误**
  * 400：请求存在语法错误
  * 401：需要有认证信息或认证失败
  * 403：没有权限
  * 404：路由不存在或没找到  
*  **5xx 服务器错误**
  * 500：服务端正在执行请求时错误
  * 503：服务端无法处理  

#### GET和POST的区别
* GET使用URL或者Cookie传递参数，而POST将数据存放在BODY中
* GET方式提交的数据有长度限制，而POST的数据可以很大
* POST比GET方式安全，数据在地址栏上不可见
* **本质区别**：GET请求是幂等性的，POST请求不是。幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。
> 因此不应该且**不能用get请求做数据的增删改这些有副作用的操作**。因为get请求是幂等的，**在网络不好的隧道中会尝试重试**。如果用get请求增数据，会有**重复操作**的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。